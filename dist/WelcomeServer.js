"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require('make-promises-safe');
const fs_1 = __importDefault(require("fs"));
const http_1 = __importDefault(require("http"));
const rsyslog_cee_1 = require("rsyslog-cee");
require('http-shutdown').extend();
const fsPromises = fs_1.default.promises;
class WelcomeServer {
    constructor(sName, sConfigPath, sPortConfigPath, oHttpListener, fAfterConfig) {
        this.bInitOnce = false;
        // Check to see that we have access to the config file.  if so, update the config var, else retry
        // When consul-template is down or restarting, the config file will be missing.  This keeps
        // the server up and ready to start while consul-template gets itself together
        this.loadConfig = async () => {
            fsPromises.access(this.sConfigPath, fs_1.default.constants.R_OK)
                .then(() => {
                this.oLogger.d('Server.Config.Ready');
                this.updateConfig().catch(oError => {
                    this.oLogger.e('Server.Config.Error', { error: oError });
                });
            })
                .catch(() => {
                this.oLogger.w('Server.Config.NotAvailable');
                setTimeout(this.loadConfig, 1000);
            });
        };
        this.updateConfig = async () => {
            const oConfig = require(this.sConfigPath); // Update the global config var
            this.fAfterConfig(oConfig, this.oLogger.getTraceTags());
            const sPort = this.getPort(oConfig);
            if (!this.bInitOnce) {
                this.bInitOnce = true;
                // Fire up the node server - initialize the http-shutdown plugin which will gracefully shutdown the server after it's done working
                this.oHTTPServer = http_1.default.createServer(this.oHttpListener);
                this.oHTTPServer.withShutdown();
                this.oHTTPServer.listen(sPort);
                this.oLogger.d('Server.Started', { port: sPort });
                this.oLogger.summary('Init');
            }
            else {
                // we've initialized before, so this must be a restart due to a config change
                this.oLogger.d('Server.Config.Changed');
                this.oHTTPServer.shutdown(() => {
                    this.oHTTPServer.listen(sPort);
                    this.oLogger.d('Server.Restarted', { port: sPort });
                    this.oLogger.summary('Init');
                });
            }
        };
        this.sConfigPath = sConfigPath;
        this.sPortConfigPath = sPortConfigPath;
        this.oHttpListener = oHttpListener;
        this.fAfterConfig = fAfterConfig;
        this.oLogger = new rsyslog_cee_1.Logger({
            service: `${sName}Server`
        });
        // When our configs are updated a `reload` call is generated by systemd.  This handles that call to reload
        process.on('SIGHUP', async () => {
            this.oLogger.d('Server.Config.SigHUP_Reload');
            delete require.cache[this.sConfigPath];
            await this.loadConfig();
        });
        this.loadConfig().catch(oError => {
            this.oLogger.e('Server.Config.Error', { error: oError });
        });
    }
    // https://stackoverflow.com/a/22129960/14651
    getPort(oConfig) {
        // @ts-ignore
        return this.sPortConfigPath.split('.').reduce((prev, curr) => prev && prev[curr], oConfig);
    }
}
exports.default = WelcomeServer;
